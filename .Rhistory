return (repsonse)
}
library(plumber)
setwd('/Users/alanhurtarte/Galileo/Product Dev/Proyecto/api')
r <- plumb("prediction_api.R")
r$run(host = "0.0.0.0", port = 8001)
#' @param data_to_test Load test
#' @post /stars/load_test
function(data_to_test) {
instances <- jsonlite::fromJSON(data_to_test)
input <- data.frame(instances)
input <- data_frame(Mean.ip = input$Mean.ip, Skewness.ip = input$Skewness.ip,
Excess.kurtosis.ip = input$Excess.kurtosis.ip, std.DMSNR.curve = input$std.DMSNR.curve)
data <- read_csv("pulsar_stars.csv")
data <- as_tibble(data)
data <- data %>%
rename(
Mean.ip = 'Mean of the integrated profile',
std.ip = 'Standard deviation of the integrated profile',
Excess.kurtosis.ip = 'Excess kurtosis of the integrated profile',
Skewness.ip = 'Skewness of the integrated profile',
Mean.DMSNR.curve = 'Mean of the DM-SNR curve',
std.DMSNR.curve = 'Standard deviation of the DM-SNR curve',
Excess.kurtosis.DMSNR.curve = 'Excess kurtosis of the DM-SNR curve',
Skewness.DMSNR.curve = 'Skewness of the DM-SNR curve',
target_class = 'target_class'
)
## 75% of the sample size
smp_size <- floor(0.75 * nrow(data))
## set the seed to make your partition reproducible
set.seed(123)
predicted <- predict(classification, input)
print(nrow(input))
train_ind <- seq(1, nrow(input))
test <- data[train_ind, ]
actual <- predict(classification, test)
## Confussino matrix
print(nrow(actual))
print(nrow(predicted))
cm = as.matrix(table(Actual = actual, Predicted = predicted)) # create the confusion matrix
## Accuracy
n = sum(cm) # number of instances
nc = nrow(cm) # number of classes
diag = diag(cm) # number of correctly classified instances per class
rowsums = apply(cm, 1, sum) # number of instances per class
colsums = apply(cm, 2, sum) # number of predictions per class
p = rowsums / n # distribution of instances over the actual classes
q = colsums / n # distribution of instances over the predicted classes
accuracy = sum(diag) / n
## Precision
precision = diag / colsums
recall = diag / rowsums
f1 = 2 * precision * recall / (precision + recall)
response <- list(status = "SUCCESS", code = "200",output = list(accuracy = accuracy, conf= cm, precision = precision, recall = recall, f1 = f1))
return (repsonse)
}
library(plumber)
setwd('/Users/alanhurtarte/Galileo/Product Dev/Proyecto/api')
r <- plumb("prediction_api.R")
r$run(host = "0.0.0.0", port = 8001)
#' @param data_to_test Load test
#' @post /stars/load_test
function(data_to_test) {
instances <- jsonlite::fromJSON(data_to_test)
input <- data.frame(instances)
input <- data_frame(Mean.ip = input$Mean.ip, Skewness.ip = input$Skewness.ip,
Excess.kurtosis.ip = input$Excess.kurtosis.ip, std.DMSNR.curve = input$std.DMSNR.curve)
data <- read_csv("pulsar_stars.csv")
data <- as_tibble(data)
data <- data %>%
rename(
Mean.ip = 'Mean of the integrated profile',
std.ip = 'Standard deviation of the integrated profile',
Excess.kurtosis.ip = 'Excess kurtosis of the integrated profile',
Skewness.ip = 'Skewness of the integrated profile',
Mean.DMSNR.curve = 'Mean of the DM-SNR curve',
std.DMSNR.curve = 'Standard deviation of the DM-SNR curve',
Excess.kurtosis.DMSNR.curve = 'Excess kurtosis of the DM-SNR curve',
Skewness.DMSNR.curve = 'Skewness of the DM-SNR curve',
target_class = 'target_class'
)
## 75% of the sample size
smp_size <- floor(0.75 * nrow(data))
## set the seed to make your partition reproducible
set.seed(123)
predicted <- predict(classification, input)
print(nrow(input))
train_ind <- seq(1, nrow(input))
test <- data[train_ind, ]
actual <- predict(classification, test)
## Confussino matrix
print(nrow(actual))
print(nrow(predicted))
cm = as.matrix(table(Actual = actual, Predicted = predicted)) # create the confusion matrix
## Accuracy
n = sum(cm) # number of instances
nc = nrow(cm) # number of classes
diag = diag(cm) # number of correctly classified instances per class
rowsums = apply(cm, 1, sum) # number of instances per class
colsums = apply(cm, 2, sum) # number of predictions per class
p = rowsums / n # distribution of instances over the actual classes
q = colsums / n # distribution of instances over the predicted classes
accuracy = sum(diag) / n
## Precision
precision = diag / colsums
recall = diag / rowsums
f1 = 2 * precision * recall / (precision + recall)
response <- list(status = "SUCCESS", code = "200",output = list(accuracy = accuracy, conf= cm, precision = precision, recall = recall, f1 = f1))
return (response)
}
library(plumber)
setwd('/Users/alanhurtarte/Galileo/Product Dev/Proyecto/api')
r <- plumb("prediction_api.R")
r$run(host = "0.0.0.0", port = 8001)
library(jsonlite)
install.packages("jsonlite")
install.packages("jsonlite")
install.packages("jsonlite")
#' @param data_to_test Load test
#' @post /stars/load_test
function(data_to_test) {
instances <- jsonlite::fromJSON(data_to_test)
input <- data.frame(instances)
input <- data_frame(Mean.ip = input$Mean.ip, Skewness.ip = input$Skewness.ip,
Excess.kurtosis.ip = input$Excess.kurtosis.ip, std.DMSNR.curve = input$std.DMSNR.curve)
data <- read_csv("pulsar_stars.csv")
data <- as_tibble(data)
data <- data %>%
rename(
Mean.ip = 'Mean of the integrated profile',
std.ip = 'Standard deviation of the integrated profile',
Excess.kurtosis.ip = 'Excess kurtosis of the integrated profile',
Skewness.ip = 'Skewness of the integrated profile',
Mean.DMSNR.curve = 'Mean of the DM-SNR curve',
std.DMSNR.curve = 'Standard deviation of the DM-SNR curve',
Excess.kurtosis.DMSNR.curve = 'Excess kurtosis of the DM-SNR curve',
Skewness.DMSNR.curve = 'Skewness of the DM-SNR curve',
target_class = 'target_class'
)
## 75% of the sample size
smp_size <- floor(0.75 * nrow(data))
## set the seed to make your partition reproducible
set.seed(123)
predicted <- predict(classification, input)
print(nrow(input))
train_ind <- seq(1, nrow(input))
test <- data[train_ind, ]
actual <- predict(classification, test)
## Confussino matrix
print(nrow(actual))
print(nrow(predicted))
cm = as.matrix(table(Actual = actual, Predicted = predicted)) # create the confusion matrix
## Accuracy
n = sum(cm) # number of instances
nc = nrow(cm) # number of classes
diag = diag(cm) # number of correctly classified instances per class
rowsums = apply(cm, 1, sum) # number of instances per class
colsums = apply(cm, 2, sum) # number of predictions per class
p = rowsums / n # distribution of instances over the actual classes
q = colsums / n # distribution of instances over the predicted classes
accuracy = sum(diag) / n
## Precision
precision = diag / colsums
recall = diag / rowsums
f1 = 2 * precision * recall / (precision + recall)
response <- list(status = "SUCCESS", code = "200",
output = list(accuracy = accuracy, conf= cm, precision = precision, recall = recall, f1 = f1))
# return (response)
jsonlite::toJSON(response)
}
library(plumber)
setwd('/Users/alanhurtarte/Galileo/Product Dev/Proyecto/api')
r <- plumb("prediction_api.R")
r$run(host = "0.0.0.0", port = 8001)
#' @param data_to_test Load test
#' @post /stars/load_test
function(data_to_test) {
instances <- jsonlite::fromJSON(data_to_test)
input <- data.frame(instances)
input <- data_frame(Mean.ip = input$Mean.ip, Skewness.ip = input$Skewness.ip,
Excess.kurtosis.ip = input$Excess.kurtosis.ip, std.DMSNR.curve = input$std.DMSNR.curve)
data <- read_csv("pulsar_stars.csv")
data <- as_tibble(data)
data <- data %>%
rename(
Mean.ip = 'Mean of the integrated profile',
std.ip = 'Standard deviation of the integrated profile',
Excess.kurtosis.ip = 'Excess kurtosis of the integrated profile',
Skewness.ip = 'Skewness of the integrated profile',
Mean.DMSNR.curve = 'Mean of the DM-SNR curve',
std.DMSNR.curve = 'Standard deviation of the DM-SNR curve',
Excess.kurtosis.DMSNR.curve = 'Excess kurtosis of the DM-SNR curve',
Skewness.DMSNR.curve = 'Skewness of the DM-SNR curve',
target_class = 'target_class'
)
## 75% of the sample size
smp_size <- floor(0.75 * nrow(data))
## set the seed to make your partition reproducible
set.seed(123)
predicted <- predict(classification, input)
print(nrow(input))
train_ind <- seq(1, nrow(input))
test <- data[train_ind, ]
actual <- predict(classification, test)
## Confussino matrix
print(nrow(actual))
print(nrow(predicted))
cm = as.matrix(table(Actual = actual, Predicted = predicted)) # create the confusion matrix
## Accuracy
n = sum(cm) # number of instances
nc = nrow(cm) # number of classes
diag = diag(cm) # number of correctly classified instances per class
rowsums = apply(cm, 1, sum) # number of instances per class
colsums = apply(cm, 2, sum) # number of predictions per class
p = rowsums / n # distribution of instances over the actual classes
q = colsums / n # distribution of instances over the predicted classes
accuracy = sum(diag) / n
## Precision
precision = diag / colsums
recall = diag / rowsums
f1 = 2 * precision * recall / (precision + recall)
response <- list(status = "SUCCESS", code = "200",
output = list(accuracy = accuracy, conf= cm, precision = precision, recall = recall, f1 = f1))
# return (response)
list(accuracy = accuracy, conf= cm, precision = precision, recall = recall, f1 = f1)
}
library(plumber)
setwd('/Users/alanhurtarte/Galileo/Product Dev/Proyecto/api')
r <- plumb("prediction_api.R")
r$run(host = "0.0.0.0", port = 8001)
#' @param data_to_test Load test
#' @post /stars/load_test
function(data_to_test) {
instances <- jsonlite::fromJSON(data_to_test)
input <- data.frame(instances)
input <- data_frame(Mean.ip = input$Mean.ip, Skewness.ip = input$Skewness.ip,
Excess.kurtosis.ip = input$Excess.kurtosis.ip, std.DMSNR.curve = input$std.DMSNR.curve)
data <- read_csv("pulsar_stars.csv")
data <- as_tibble(data)
data <- data %>%
rename(
Mean.ip = 'Mean of the integrated profile',
std.ip = 'Standard deviation of the integrated profile',
Excess.kurtosis.ip = 'Excess kurtosis of the integrated profile',
Skewness.ip = 'Skewness of the integrated profile',
Mean.DMSNR.curve = 'Mean of the DM-SNR curve',
std.DMSNR.curve = 'Standard deviation of the DM-SNR curve',
Excess.kurtosis.DMSNR.curve = 'Excess kurtosis of the DM-SNR curve',
Skewness.DMSNR.curve = 'Skewness of the DM-SNR curve',
target_class = 'target_class'
)
## 75% of the sample size
smp_size <- floor(0.75 * nrow(data))
## set the seed to make your partition reproducible
set.seed(123)
predicted <- predict(classification, input)
print(nrow(input))
train_ind <- seq(1, nrow(input))
test <- data[train_ind, ]
actual <- predict(classification, test)
## Confussino matrix
print(nrow(actual))
print(nrow(predicted))
cm = as.matrix(table(Actual = actual, Predicted = predicted)) # create the confusion matrix
## Accuracy
n = sum(cm) # number of instances
nc = nrow(cm) # number of classes
diag = diag(cm) # number of correctly classified instances per class
rowsums = apply(cm, 1, sum) # number of instances per class
colsums = apply(cm, 2, sum) # number of predictions per class
p = rowsums / n # distribution of instances over the actual classes
q = colsums / n # distribution of instances over the predicted classes
accuracy = sum(diag) / n
## Precision
precision = diag / colsums
recall = diag / rowsums
f1 = 2 * precision * recall / (precision + recall)
#response <- list(status = "SUCCESS", code = "200",
#                output = list(accuracy = accuracy, conf= cm, precision = precision, recall = recall, f1 = f1))
# return (response)
list(accuracy = accuracy, conf= cm, precision = precision, recall = recall, f1 = f1)
}
library(plumber)
setwd('/Users/alanhurtarte/Galileo/Product Dev/Proyecto/api')
r <- plumb("prediction_api.R")
r$run(host = "0.0.0.0", port = 8001)
#' @param data_to_test Load test
#' @post /stars/load_test
function(data_to_test) {
instances <- jsonlite::fromJSON(data_to_test)
input <- data.frame(instances)
input <- data_frame(Mean.ip = input$Mean.ip, Skewness.ip = input$Skewness.ip,
Excess.kurtosis.ip = input$Excess.kurtosis.ip, std.DMSNR.curve = input$std.DMSNR.curve)
data <- read_csv("pulsar_stars.csv")
data <- as_tibble(data)
data <- data %>%
rename(
Mean.ip = 'Mean of the integrated profile',
std.ip = 'Standard deviation of the integrated profile',
Excess.kurtosis.ip = 'Excess kurtosis of the integrated profile',
Skewness.ip = 'Skewness of the integrated profile',
Mean.DMSNR.curve = 'Mean of the DM-SNR curve',
std.DMSNR.curve = 'Standard deviation of the DM-SNR curve',
Excess.kurtosis.DMSNR.curve = 'Excess kurtosis of the DM-SNR curve',
Skewness.DMSNR.curve = 'Skewness of the DM-SNR curve',
target_class = 'target_class'
)
## 75% of the sample size
smp_size <- floor(0.75 * nrow(data))
## set the seed to make your partition reproducible
set.seed(123)
predicted <- predict(classification, input)
print(nrow(input))
train_ind <- seq(1, nrow(input))
test <- data[train_ind, ]
actual <- predict(classification, test)
## Confussino matrix
print(nrow(actual))
print(nrow(predicted))
cm = as.matrix(table(Actual = actual, Predicted = predicted)) # create the confusion matrix
## Accuracy
n = sum(cm) # number of instances
nc = nrow(cm) # number of classes
diag = diag(cm) # number of correctly classified instances per class
rowsums = apply(cm, 1, sum) # number of instances per class
colsums = apply(cm, 2, sum) # number of predictions per class
p = rowsums / n # distribution of instances over the actual classes
q = colsums / n # distribution of instances over the predicted classes
accuracy = sum(diag) / n
## Precision
precision = diag / colsums
recall = diag / rowsums
f1 = 2 * precision * recall / (precision + recall)
#response <- list(status = "SUCCESS", code = "200",
#                output = list(accuracy = accuracy, conf= cm, precision = precision, recall = recall, f1 = f1))
# return (response)
data_frame(accuracy = accuracy, conf= cm, precision = precision, recall = recall, f1 = f1)
}
library(plumber)
setwd('/Users/alanhurtarte/Galileo/Product Dev/Proyecto/api')
r <- plumb("prediction_api.R")
r$run(host = "0.0.0.0", port = 8001)
#' @param data_to_test Load test
#' @post /stars/load_test
function(data_to_test) {
instances <- jsonlite::fromJSON(data_to_test)
input <- data.frame(instances)
input <- data_frame(Mean.ip = input$Mean.ip, Skewness.ip = input$Skewness.ip,
Excess.kurtosis.ip = input$Excess.kurtosis.ip, std.DMSNR.curve = input$std.DMSNR.curve)
data <- read_csv("pulsar_stars.csv")
data <- as_tibble(data)
data <- data %>%
rename(
Mean.ip = 'Mean of the integrated profile',
std.ip = 'Standard deviation of the integrated profile',
Excess.kurtosis.ip = 'Excess kurtosis of the integrated profile',
Skewness.ip = 'Skewness of the integrated profile',
Mean.DMSNR.curve = 'Mean of the DM-SNR curve',
std.DMSNR.curve = 'Standard deviation of the DM-SNR curve',
Excess.kurtosis.DMSNR.curve = 'Excess kurtosis of the DM-SNR curve',
Skewness.DMSNR.curve = 'Skewness of the DM-SNR curve',
target_class = 'target_class'
)
## 75% of the sample size
smp_size <- floor(0.75 * nrow(data))
## set the seed to make your partition reproducible
set.seed(123)
predicted <- predict(classification, input)
print(nrow(input))
train_ind <- seq(1, nrow(input))
test <- data[train_ind, ]
actual <- predict(classification, test)
## Confussino matrix
print(nrow(actual))
print(nrow(predicted))
cm = as.matrix(table(Actual = actual, Predicted = predicted)) # create the confusion matrix
## Accuracy
n = sum(cm) # number of instances
nc = nrow(cm) # number of classes
diag = diag(cm) # number of correctly classified instances per class
rowsums = apply(cm, 1, sum) # number of instances per class
colsums = apply(cm, 2, sum) # number of predictions per class
p = rowsums / n # distribution of instances over the actual classes
q = colsums / n # distribution of instances over the predicted classes
accuracy = sum(diag) / n
## Precision
precision = diag / colsums
recall = diag / rowsums
f1 = 2 * precision * recall / (precision + recall)
#response <- list(status = "SUCCESS", code = "200",
#                output = list(accuracy = accuracy, conf= cm, precision = precision, recall = recall, f1 = f1))
# return (response)
as.data.frame(list(accuracy = accuracy, conf= cm, precision = precision, recall = recall, f1 = f1))
}
library(plumber)
setwd('/Users/alanhurtarte/Galileo/Product Dev/Proyecto/api')
r <- plumb("prediction_api.R")
r$run(host = "0.0.0.0", port = 8001)
#' @param data_to_test Load test
#' @post /stars/load_test
function(data_to_test) {
instances <- jsonlite::fromJSON(data_to_test)
input <- data.frame(instances)
input <- data_frame(Mean.ip = input$Mean.ip, Skewness.ip = input$Skewness.ip,
Excess.kurtosis.ip = input$Excess.kurtosis.ip, std.DMSNR.curve = input$std.DMSNR.curve)
data <- read_csv("pulsar_stars.csv")
data <- as_tibble(data)
data <- data %>%
rename(
Mean.ip = 'Mean of the integrated profile',
std.ip = 'Standard deviation of the integrated profile',
Excess.kurtosis.ip = 'Excess kurtosis of the integrated profile',
Skewness.ip = 'Skewness of the integrated profile',
Mean.DMSNR.curve = 'Mean of the DM-SNR curve',
std.DMSNR.curve = 'Standard deviation of the DM-SNR curve',
Excess.kurtosis.DMSNR.curve = 'Excess kurtosis of the DM-SNR curve',
Skewness.DMSNR.curve = 'Skewness of the DM-SNR curve',
target_class = 'target_class'
)
## 75% of the sample size
smp_size <- floor(0.75 * nrow(data))
## set the seed to make your partition reproducible
set.seed(123)
predicted <- predict(classification, input)
print(nrow(input))
train_ind <- seq(1, nrow(input))
test <- data[train_ind, ]
actual <- predict(classification, test)
## Confussino matrix
print(nrow(actual))
print(nrow(predicted))
cm = as.matrix(table(Actual = actual, Predicted = predicted)) # create the confusion matrix
## Accuracy
n = sum(cm) # number of instances
nc = nrow(cm) # number of classes
diag = diag(cm) # number of correctly classified instances per class
rowsums = apply(cm, 1, sum) # number of instances per class
colsums = apply(cm, 2, sum) # number of predictions per class
p = rowsums / n # distribution of instances over the actual classes
q = colsums / n # distribution of instances over the predicted classes
accuracy = sum(diag) / n
## Precision
precision = diag / colsums
recall = diag / rowsums
f1 = 2 * precision * recall / (precision + recall)
#response <- list(status = "SUCCESS", code = "200",
#                output = list(accuracy = accuracy, conf= cm, precision = precision, recall = recall, f1 = f1))
# return (response)
response <- list(accuracy = accuracy, conf= cm, precision = precision, recall = recall, f1 = f1)
return (response)
}
library(plumber)
setwd('/Users/alanhurtarte/Galileo/Product Dev/Proyecto/api')
r <- plumb("prediction_api.R")
r$run(host = "0.0.0.0", port = 8001)
#' @param data_to_test Load test
#' @post /stars/load_test
function(data_to_test) {
instances <- jsonlite::fromJSON(data_to_test)
input <- data.frame(instances)
input <- data_frame(Mean.ip = input$Mean.ip, Skewness.ip = input$Skewness.ip,
Excess.kurtosis.ip = input$Excess.kurtosis.ip, std.DMSNR.curve = input$std.DMSNR.curve)
data <- read_csv("pulsar_stars.csv")
data <- as_tibble(data)
data <- data %>%
rename(
Mean.ip = 'Mean of the integrated profile',
std.ip = 'Standard deviation of the integrated profile',
Excess.kurtosis.ip = 'Excess kurtosis of the integrated profile',
Skewness.ip = 'Skewness of the integrated profile',
Mean.DMSNR.curve = 'Mean of the DM-SNR curve',
std.DMSNR.curve = 'Standard deviation of the DM-SNR curve',
Excess.kurtosis.DMSNR.curve = 'Excess kurtosis of the DM-SNR curve',
Skewness.DMSNR.curve = 'Skewness of the DM-SNR curve',
target_class = 'target_class'
)
## 75% of the sample size
smp_size <- floor(0.75 * nrow(data))
## set the seed to make your partition reproducible
set.seed(123)
predicted <- predict(classification, input)
print(nrow(input))
train_ind <- seq(1, nrow(input))
test <- data[train_ind, ]
actual <- predict(classification, test)
## Confussino matrix
print(nrow(actual))
print(nrow(predicted))
cm = as.matrix(table(Actual = actual, Predicted = predicted)) # create the confusion matrix
## Accuracy
n = sum(cm) # number of instances
nc = nrow(cm) # number of classes
diag = diag(cm) # number of correctly classified instances per class
rowsums = apply(cm, 1, sum) # number of instances per class
colsums = apply(cm, 2, sum) # number of predictions per class
p = rowsums / n # distribution of instances over the actual classes
q = colsums / n # distribution of instances over the predicted classes
accuracy = sum(diag) / n
## Precision
precision = diag / colsums
recall = diag / rowsums
f1 = 2 * precision * recall / (precision + recall)
#response <- list(status = "SUCCESS", code = "200",
#                output = list(accuracy = accuracy, conf= cm, precision = precision, recall = recall, f1 = f1))
# return (response)
response <- list(accuracy = accuracy, conf= cm, precision = precision, recall = recall, f1 = f1)
return (toJSON(response, force = TRUE))
}
library(plumber)
setwd('/Users/alanhurtarte/Galileo/Product Dev/Proyecto/api')
r <- plumb("prediction_api.R")
r$run(host = "0.0.0.0", port = 8001)
